import com.sun.jini.config.KeyStores;

import net.jini.core.constraint.ClientAuthentication;
import net.jini.core.constraint.ConstraintAlternatives;
import net.jini.core.constraint.Integrity;
import net.jini.core.constraint.InvocationConstraint;
import net.jini.core.constraint.InvocationConstraints;
import net.jini.core.constraint.ServerAuthentication;
import net.jini.core.constraint.ServerMinPrincipal;

import net.jini.security.AuthenticationPermission;
import net.jini.constraint.BasicMethodConstraints;
import net.jini.security.BasicProxyPreparer;

import net.jini.jeri.ProxyTrustILFactory;
import net.jini.jeri.BasicJeriExporter;

import net.jini.jeri.ssl.SslServerEndpoint;

import javax.security.auth.login.LoginContext;

import java.security.KeyStore;
import java.security.Permission;
import java.util.Arrays;
import java.util.Collections;

import net.jini.lookup.entry.Name;
import net.jini.lookup.entry.ServiceInfo;

//Inca X rutime entries
import com.incax.jini.entry.Timestamp;



org.jini.simple.service {

   
    private static truststore = KeyStores.getKeyStore("${incaxTruststore}", null);

    
    private static clientKey    = KeyStores.getX500Principal("client",truststore);    
    private static reggieKey    = KeyStores.getX500Principal("reggie",truststore);
    
    //"server" is the generic key for services generated by the Inca X wizard
    private static serviceKey 	 = KeyStores.getX500Principal("server", truststore);
	 
    private static clientPublicKeyCert     = Collections.singleton(clientKey);
    private static reggiePublicKeyCert     = Collections.singleton(reggieKey);
    private static servicePublicKeyCert  = Collections.singleton(serviceKey);
 	
    private static clientKeyArray = new Object[] { clientKey,
                                                   reggieKey,
                                                   serviceKey
                                                  };

    private static clientPublicKeys = new java.util.HashSet(Arrays.asList(clientKeyArray));

   
    private serviceEndpoint = SslServerEndpoint.getInstance(0);

   
    private serviceConstraints = new BasicMethodConstraints(
    		new InvocationConstraints(new InvocationConstraint[]{ Integrity.YES, 
    							ClientAuthentication.YES },null));

    
    private serviceILFactory = new ProxyTrustILFactory(serviceConstraints,
                                                       org.jini.simple.service.MyServicePermission.class);

    
    serverExporter = new BasicJeriExporter(serviceEndpoint, serviceILFactory);

    
    private listenerPrincipals = new InvocationConstraint[]{ new ServerMinPrincipal(clientPublicKeyCert),
                                                             new ServerMinPrincipal(reggiePublicKeyCert),
                                                             new ServerMinPrincipal(servicePublicKeyCert)
                                                           };
    private serviceListenerConstraints
         = new BasicMethodConstraints( 
            new InvocationConstraints( 
                new InvocationConstraint[]{ 
                    Integrity.YES,
                    ClientAuthentication.YES,
                    ServerAuthentication.YES,
                    new ConstraintAlternatives(listenerPrincipals)},null) );

    
    listenerPreparer = 
        new BasicProxyPreparer( true, serviceListenerConstraints,
               new Permission[] { new AuthenticationPermission(servicePublicKeyCert,
                                 clientPublicKeys,"connect") } );

   
    loginContext = new LoginContext("service.jaas.login");

    	initialLookupAttributes=new net.jini.core.entry.Entry[]{
		new Name("MyService"),
		new Timestamp(),
		//ServiceUI 
		org.jini.simple.service.MyServiceUI.getUIDescriptor()
	};



    initialLookupGroups = new String[] {"incaX-secure"};

}


shared.entries {

    private serviceLookupConstraints
         = new BasicMethodConstraints( 
            new InvocationConstraints( 
                new InvocationConstraint[]{ Integrity.YES,
                                          ClientAuthentication.YES,
                                          ServerAuthentication.YES,
                                          new ServerMinPrincipal(org.jini.simple.service.reggiePublicKeyCert)
                                         },null));
}


net.jini.discovery.LookupDiscovery {

  
    registrarPreparer = 
    		new BasicProxyPreparer( true,
                             shared.entries.serviceLookupConstraints,
                             new Permission[] { 
                             		new AuthenticationPermission(
                             		 org.jini.simple.service.servicePublicKeyCert,
                                org.jini.simple.service.reggiePublicKeyCert,
                                "connect")});

}


net.jini.lookup.JoinManager {

    
    registrarPreparer    = new BasicProxyPreparer( false, shared.entries.serviceLookupConstraints, null );
    registrationPreparer = new BasicProxyPreparer( false, shared.entries.serviceLookupConstraints, null );
    serviceLeasePreparer = new BasicProxyPreparer( false, shared.entries.serviceLookupConstraints, null );

}

